/*
                            __;φφφ≥,,╓╓,__
                           _φ░░░░░░░░░░░░░φ,_
                           φ░░░░░░░░░░░░╚░░░░_
                           ░░░░░░░░░░░░░░░▒▒░▒_
                          _░░░░░░░░░░░░░░░░╬▒░░_
    _≤,                    _░░░░░░░░░░░░░░░░╠░░ε
    _Σ░≥_                   `░░░░░░░░░░░░░░░╚░░░_
     _φ░░                     ░░░░░░░░░░░░░░░▒░░
       ░░░,                    `░░░░░░░░░░░░░╠░░___
       _░░░░░≥,                 _`░░░░░░░░░░░░░░░░░φ≥, _
       ▒░░░░░░░░,_                _ ░░░░░░░░░░░░░░░░░░░░░≥,_
      ▐░░░░░░░░░░░                 φ░░░░░░░░░░░░░░░░░░░░░░░▒,
       ░░░░░░░░░░░[             _;░░░░░░░░░░░░░░░░░░░░░░░░░░░
       \░░░░░░░░░░░»;;--,,. _  ,░░░░░░░░░░░░░░░░░░░░░░░░░░░░░Γ
       _`░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░φ,,
         _"░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░"=░░░░░░░░░░░░░░░░░
            Σ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░_    `╙δ░░░░Γ"  ²░Γ_
         ,φ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░_
       _φ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░φ░░≥_
      ,▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░≥
     ,░░░░░░░░░░░░░░░░░╠▒░▐░░░░░░░░░░░░░░░╚░░░░░≥
    _░░░░░░░░░░░░░░░░░░▒░░▐░░░░░░░░░░░░░░░░╚▒░░░░░
    φ░░░░░░░░░░░░░░░░░φ░░Γ'░░░░░░░░░░░░░░░░░░░░░░░░
    ░░░░░░░░░░░░░░░░░░░░░_ ░░░░░░░░░░░░░░░░░░░░░░░░[
    ╚░░░░░░░░░░░░░░░░░░░_  └░░░░░░░░░░░░░░░░░░░░░░░░
    _╚░░░░░░░░░░░░░▒"^     _7░░░░░░░░░░░░░░░░░░░░░░Γ
     _`╚░░░░░░░░╚²_          \░░░░░░░░░░░░░░░░░░░░Γ
         ____                _`░░░░░░░░░░░░░░░Γ╙`
                               _"φ░░░░░░░░░░╚_
                                 _ `""²ⁿ""

        ██╗         ██╗   ██╗    ██╗  ██╗    ██╗   ██╗
        ██║         ██║   ██║    ╚██╗██╔╝    ╚██╗ ██╔╝
        ██║         ██║   ██║     ╚███╔╝      ╚████╔╝ 
        ██║         ██║   ██║     ██╔██╗       ╚██╔╝  
        ███████╗    ╚██████╔╝    ██╔╝ ██╗       ██║   
        ╚══════╝     ╚═════╝     ╚═╝  ╚═╝       ╚═╝   
*/

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./LibPart.sol";
import "./tokens/ERC2981/IERC2981.sol";
import "./exchange/lib/LibBP.sol";

//InterfaceID = 0x25292224
abstract contract RoyaltiesV1Luxy is IERC2981 {
    using LibBP for uint256;
    event RoyaltiesSet(uint256 tokenId, LibPart.Part[] royalties);
    event RoyaltieAccountUpdate(
        uint256 tokenId,
        uint256 index,
        address previousAccount,
        address newAccount
    );
    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);
    
    mapping(uint256 => LibPart.Part[]) internal royalties;

    function getRoyalties(uint256 id)
        public
        view
        virtual
        returns (LibPart.Part[] memory)
    {
        return royalties[id];
    }

    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
        external
        view
        override
        returns (address receiver, uint256 royaltyAmount)
    {
        require(royalties[_tokenId].length != 0, "Royalties not set yet");
        require(
            royalties[_tokenId].length == 1,
            "Multiples Royalties is not supported by EIP2981, use LuxyRoyaltiesV1"
        );
        require(
            royalties[_tokenId][0].value <= 9800,
            "Royalties are too high (>98%)"
        );
        royaltyAmount = _salePrice.bp(royalties[_tokenId][0].value);
        receiver = royalties[_tokenId][0].account;
    }


    //Not deployed yet current InterfaceID is 0x25292224
    // function calcRoyaltiesInterfaceId() external pure returns (bytes4) {
    //     return type(RoyaltiesV1Luxy).interfaceId;
    // }

    function _setRoyalties(uint256 id, LibPart.Part[] memory _royalties)
        internal
    {
       uint256 totalValue;
        for (uint i = 0; i < _royalties.length; ++i) {
            require(_royalties[i].account != address(0x0), "Recipient should be present");
            require(_royalties[i].value != 0, "Royalty value should be positive");
            totalValue += _royalties[i].value;
            royalties[id].push(_royalties[i]);
        }
        require(totalValue < 10000, "Royalty total value should be < 10000");
        _onRoyaltiesSet(id, _royalties);
    }
    function _onRoyaltiesSet(uint256 id, LibPart.Part[] memory _royalties) internal {
        address[] memory recipients = new address[](_royalties.length);
        uint[] memory bps = new uint[](_royalties.length);
        for (uint i = 0; i < _royalties.length; ++i) {
            recipients[i] = _royalties[i].account;
            bps[i] = _royalties[i].value;
        }
       emit SecondarySaleFees(id, recipients, bps); 
    }

    function _updateAccount(
        uint256 _id,
        address _from,
        address _to
    ) internal {
        uint256 length = royalties[_id].length;
        address previousAccount = address(0x0);
        uint256 index = 0;
        for (uint256 i = 0; i < length; i++) {
            if (royalties[_id][i].account == _from) {
                previousAccount = royalties[_id][i].account;
                index = i;
                royalties[_id][i].account = payable(address(uint160(_to)));
            }
        }
        require(
            previousAccount != address(0x0),
            "Account not found, are you using the correct wallet?"
        );
        emit RoyaltieAccountUpdate(
            _id,
            index,
            previousAccount,
            royalties[_id][index].account
        );
    }


    uint256[50] private __gap;
}
